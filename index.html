<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>USA Van+Rail — תיקון אינדקס</title>
  <link rel="shortcut icon" href="/favicon.ico">
  <!-- Leaflet CSS (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-sA+e2e/6k9gGk7x3b1g4xgq7k3G1kQZ6a2m9g9+0x7M=" crossorigin=""/>
  <style>
    :root {
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      direction: rtl;
      text-align: right; /* user prefers right-aligned Hebrew with English/numbers */
    }
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    #topbar { padding: 10px; background: #0b2447; color: white; display:flex; align-items:center; gap:12px; }
    #map { height: calc(100% - 56px); }
    .info { padding: 8px; background: rgba(255,255,255,0.9); border-radius:6px; }
  </style>
</head>
<body>
  <div id="topbar">
    <div style="flex:1">
      <strong>USA Van+Rail — תיקון אינדקס (גרסה לתיקון)</strong>
      <div style="font-size:13px; opacity:0.9">גרסה שמונעת שגיאות JSON.parse כשהקובץ /itinerary_spec.txt חסר או מחזיר HTML.</div>
    </div>
    <div class="info" id="status">טעינה…</div>
  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-o9N1j8kTazbK2P8qvKq7m4R5h3b0aKzQp2ztX+3sZ+M=" crossorigin=""></script>

  <script>
    // Default fallback itinerary (safe minimal structure)
    const FALLBACK_ITINERARY = {
      "points": [
        { "id":"fallback-1", "name":"נקודת דוגמה — אין נתוני מסלול", "type":"town", "coords":[41.8781,-87.6298], "stay_duration_min":60, "description":"קובץ itinerary_spec.txt לא נמצא או לא קריא. זו נקודת ברירת מחדל.","parking":"unknown","price_estimate":"unknown","slug":"" }
      ],
      "segments": []
    };

    // Utility: safe fetch + parse with fallbacks
    async function loadItinerary() {
      try {
        const resp = await fetch('/itinerary_spec.txt', {cache: "no-store"});
        if (!resp.ok) {
          console.warn('itinerary_spec.txt fetch non-ok:', resp.status);
          return FALLBACK_ITINERARY;
        }
        const ct = resp.headers.get('content-type') || '';
        const text = await resp.text();

        // If server returned HTML (index.html) or anything starting with '<', avoid JSON.parse
        if (text.trim().startsWith('<')) {
          console.warn('itinerary_spec.txt appears to contain HTML (likely a routing fallback). Using fallback itinerary.');
          return FALLBACK_ITINERARY;
        }

        // If content-type indicates JSON, try parse; otherwise try parse with try/catch
        if (ct.includes('application/json') || text.trim().startsWith('{') || text.trim().startsWith('[')) {
          try {
            const parsed = JSON.parse(text);
            // Basic validation: expect parsed.points or array
            if (parsed && (Array.isArray(parsed.points) || Array.isArray(parsed))) {
              return parsed;
            } else {
              console.warn('Parsed JSON did not contain expected structure. Using fallback.');
              return FALLBACK_ITINERARY;
            }
          } catch (e) {
            console.error('JSON.parse failed for itinerary_spec.txt:', e);
            return FALLBACK_ITINERARY;
          }
        } else {
          console.warn('itinerary_spec.txt not JSON content-type and does not look like JSON. Using fallback.');
          return FALLBACK_ITINERARY;
        }
      } catch (err) {
        console.error('Error fetching itinerary_spec.txt:', err);
        return FALLBACK_ITINERARY;
      }
    }

    // Initialize map and render points
    async function init() {
      const statusEl = document.getElementById('status');
      const data = await loadItinerary();
      statusEl.textContent = 'נתונים נטענו — נקודות: ' + (Array.isArray(data.points) ? data.points.length : '?');

      // Create map
      const map = L.map('map', {zoomControl: true}).setView([39.5, -98.35], 4);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '© OpenStreetMap'
      }).addTo(map);

      // If points array is present and non-empty, add markers + fit bounds
      const pts = Array.isArray(data.points) ? data.points : [];
      if (pts.length === 0) {
        // add fallback center marker
        L.marker([39.5, -98.35]).addTo(map).bindPopup('אין נקודות במסלול כרגע.');
      } else {
        const markers = [];
        pts.forEach(p => {
          const lat = (p.coords && p.coords[0]) || (p.coords && p.coords.lat);
          const lng = (p.coords && p.coords[1]) || (p.coords && p.coords.lng);
          if (typeof lat === 'number' && typeof lng === 'number') {
            const m = L.marker([lat, lng]).addTo(map);
            const popupHtml = `<div style="direction:rtl; text-align:right"><strong>${p.name || 'בלי שם'}</strong><div style="font-size:13px">${p.description || ''}</div></div>`;
            m.bindPopup(popupHtml);
            markers.push(m);
          }
        });
        if (markers.length) {
          const group = L.featureGroup(markers);
          map.fitBounds(group.getBounds().pad(0.2));
        }
      }
    }

    // Run
    init();
  </script>
</body>
</html>
